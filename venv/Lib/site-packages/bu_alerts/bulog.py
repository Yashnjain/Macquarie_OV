import json
import datetime
import socket
import datetime
import logging
import os
import pathlib
import datetime
import pandas as pd
import functools
from bu_snowflake import get_engine
from pythonjsonlogger import jsonlogger
from snowflake.sqlalchemy import VARIANT
from snowflake.connector.pandas_tools import pd_writer

logpath = pathlib.Path('./logs/').absolute().__str__()
if not os.path.exists(logpath):
    os.makedirs('logs')
now = datetime.datetime.today().strftime("%Y%m%d%H%M%S")


def add_file_logging(logger, process_name=None) -> str:
    """Module handler for log file.

    :param logger: Logger object
    :type logger: :class:`logging.Logger`
    :param process_name: Name of the process to set., defaults to process
    :type process_name: str, optional
    """
    logfilename = pathlib.Path(
        f'./logs/process_run_{now}.log').absolute().__str__()
    if process_name:
        logfilename = pathlib.Path(
            f'./logs/{process_name}_run_{now}.log').absolute().__str__()
    handler = logging.FileHandler(logfilename, mode='w')

    if not logger.handlers:
        formatter = CustomJsonFormatter(
            '%(timestamp)s %(level)s %(name)s %(lineno)d %(message)s')
        handler.setFormatter(formatter)
        handler.setLevel(logging.INFO)
        logger.addHandler(handler)
    logger.propagate = False
    return logfilename


def bulog(
    process_name: str,
    table_name: str,
    status: str,
    process_owner: str = '',
    row_count: int = 0,
    log: str = '',
    database: str = '',
    warehouse: str = '',
    engine=None
) -> bool:
    """BULOG functionality to send the status log entry to bulog table.

    :param process_name: Name of the process.
    :type process_name: str
    :param status: Status of the process like, Started, Ended, Failed etc.
    :type status: str
    :param table_name: Name of the table for which job is running.
    :type table_name: str
    :param row_count: Count of rows affected during the process
    :type row_count: int
    :param log: JSON string as the log.
    :type log: str
    :param database: Database name your code is working with, defaults to 'powerdb'
    :type database: str, optional
    :param warehouse: Warehouse name your code is working with, defaults to 'ITPYTHON_WH'
    :type warehouse: str, optional
    :return: Returns a status flag True/False
    :rtype: bool
    """

    done = False
    starttime = datetime.datetime.now().__str__()
    try:
        log = json.loads(log)
    except ValueError:
        log = json.loads('[{"Error":"Invalid JSON String"}]')

    database = database or "powerdb"
    warehouse = warehouse or "ITPYTHON_WH"
    role = f"OWNER_{database.upper()}"
    processed_by = socket.gethostname()
    df = pd.DataFrame(
        columns=[
            'PROCESS_NAME', 'PROCESSED_BY', 'STATUSTIME', 'STATUS',
            'TABLE_NAME', 'ROW_COUNT', 'LOG', 'WAREHOUSE', 'PROCESS_OWNER'
        ],
        data=[[
            process_name.upper(),
            processed_by.upper(),
            starttime, status.upper(),
            table_name.upper(),
            row_count,
            log,
            warehouse.upper(),
            process_owner.upper()
        ]]
    )
    if not engine:
        engine = get_engine(
            database=database,
            warehouse=warehouse,
            role=role,
            schema='PLOG'
        )

    try:
        with engine.connect() as con:
            df.to_sql(
                name='process_log',
                con=con,
                if_exists='append',
                dtype={'LOG': VARIANT},
                index=False,
                method=functools.partial(pd_writer, quote_identifiers=False)
            )
        print(f'BULOG entry successfully added in {database}.plog.process_log')
        done = True
    except Exception as e:
        print(f"Error while inserting in BULOG, More Details : {str(e)}")
    return done


class CustomJsonFormatter(jsonlogger.JsonFormatter):
    def add_fields(self, log_record, record, message_dict):
        super(CustomJsonFormatter, self).add_fields(
            log_record, record, message_dict)
        if not log_record.get('timestamp'):
            # this doesn't use record.created, so it is slightly off
            now = datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            log_record['timestamp'] = now
        if log_record.get('level'):
            log_record['level'] = log_record['level'].upper()
        else:
            log_record['level'] = record.levelname


if __name__ == "__main__":
    bulog(
        process_name="Testing",
        process_owner='chetan',
        status='Started',
        table_name='PTEST',
        row_count=0,
        log='[{"Message": "This is a log entry","Exit Code": 0}]',
        database='powerdb_dev'
    )
